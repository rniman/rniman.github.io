---
title: 게임 인공지능 | 게임과 의사 결정 - 3주차 강의 정리
date: 2025-06-19 00:13:20 +0900
categories: [Study, Study\GameAi]
tags: [AI, Game AI, 강의정리, STAR-MOOC]
author: "rniman"                            # for single entry
# or
# authors: [<author1_id>, <author2_id>]   # for multiple entries
description: "이 글은 게임 인공지능 강의 3주차 내용을 정리한 것입니다."

comments: false # 댓글 기능
---

# 게임 AI 의사결정 시스템 완전 정리

게임 속 NPC는 어떻게 움직이고 결정을 내릴까? 단순히 길을 찾는 것을 넘어서, 언제 어디로 가야 하고 무엇을 해야 하는지를 결정하는 것이 바로 게임 AI의 핵심이다. 이번 포스트에서는 게임 AI가 의사결정을 내리는 다양한 방법들을 살펴보자.

---

## AI 의사결정의 두 가지 접근법

게임 AI의 의사결정 방식은 크게 두 가지로 나뉜다.

### AI Authoring (설계된 AI)

게임 디자이너가 각 상황에서 AI가 무엇을 할지 미리 결정해두는 방법이다. 이는 하드코딩된 접근법으로, 유한 상태 기계(FSM)나 규칙 기반 시스템을 사용한다.

**장점:**

- 게임 디자이너의 의도대로 정확히 작동한다
- 예측 가능한 행동을 보인다
- 디자이너가 전문 지식을 가진 경우 효과적이다

**단점:**

- 모든 상황을 미리 정의해야 한다
- 유연성이 부족하다

### Autonomous AI (자율적 AI)

AI가 스스로 의사결정을 하고 전략을 만들어내는 방법이다.

**장점:**

- 예측하지 못한 새로운 전략이 나타날 수 있다
- 게임의 재미가 향상될 수 있다
- 목적 지향적인 행동을 보인다

**단점:**

- 디자이너가 예상하지 못한 결과가 나올 수 있다
- 구현이 복잡하다

---

## 스크립팅: 가장 기본적인 방법

대부분의 게임 AI는 스크립팅으로 구현된다. Lua, Python, C# 같은 언어를 사용하여 AI의 행동을 기술한다.

### 스크립팅 예제

```
If(time > 200 && notRunning) startRunning(Building5)
// 200스텝 지난 후 캐릭터가 뛰지 않으면 빌딩5까지 뛰어라

If(healthpoints < 100 && nearMonster) startRunning(Home)
// 체력이 100 미만이고 근처에 몬스터가 있으면 본진으로 돌아가라

If(damage > 300 && Speed > 100) slowdown(Car)
// 차량 데미지가 300 초과이고 속도가 100 초과면 속도를 낮춰라

```

**장점:**

- 프로그래밍 언어 중 비교적 쉽다
- 디자이너가 원하는 캐릭터 구현이 가능하다

**단점:**

- 모든 상황을 사전에 기술해야 하는 노동집약적 작업이다
- 플레이어에게 적응하지 못한다

---

## 복잡한 의사결정을 위한 고급 기법들

게임이 복잡해질수록 단순한 스크립팅으로는 한계가 있다. 이를 해결하기 위해 다음과 같은 방법들이 사용된다.

### 유한 상태 기계 (FSM)
가장 기본적인 AI 행동 모델링 방법이다. AI의 상태(State)와 상태 간의 전이(Transition)를 정의하여 행동을 제어한다.

**구성 요소:**
- **상태(State)**: AI가 현재 수행하고 있는 행동 (예: 순찰, 추격, 공격, 도망)
- **전이(Transition)**: 한 상태에서 다른 상태로 변경되는 조건
- **이벤트(Event)**: 상태 전이를 발생시키는 조건 (예: 적 발견, 체력 부족)

**팩맨 예제:**<br>
![팩맨 유한 상태 기계 예제](assets/img/STAR-MOOC/Game-AI/FSM.png)
_팩맨의 유령들은 '추격', '도망', '집으로 돌아가기' 등의 상태를 가지며, 특정 조건에 따라 상태를 전환한다._

### 계층적 유한 상태 기계 (HFSM)

기본 FSM의 한계를 극복하기 위해 상태 내부에 또 다른 FSM을 두는 방식이다. 계층화를 통해 복잡성을 줄일 수 있다.

### 결정 트리 (Decision Tree)

여러 개의 행동을 체계적으로 조직화하는 방법이다. Halo 2 같은 상용 게임에서 널리 사용된다.

**장점:**

- 기존 트리의 재활용이 가능하다
- 비주얼 에디터로 설계할 수 있다
- 프로그래밍 경험이 없어도 행동 설계가 가능하다

### 행동 트리 (Behavior Tree)

현대 게임에서 가장 널리 쓰이는 방법 중 하나다.

**구성 요소:**

- **Conditions**: 참/거짓을 테스트 (문이 있는가? 플레이어가 가까이 있는가?)
- **Actions**: 실제 행동 (애니메이션 재생, 소리 효과, 길찾기 등)
- **Composites**: 실행 순서 결정 (Sequence는 순차 실행, Selector는 선택 실행)

![간단한 행동 트리 예제](assets/img/STAR-MOOC/Game-AI/Behavior tree.png)
_간단한 행동 트리 예제_

---

## 결정 이론을 활용한 자율적 AI

더욱 복잡하고 자율적인 AI를 위해서는 결정 이론(Decision Theory)을 사용할 수 있다.

### Utility 함수의 활용

AI에게 각 상황을 수치화할 수 있는 Utility 함수를 제공한다. AI는 가장 높은 Utility 값을 가지는 행동을 선택한다.

**체스 예제:**

- 룩 잡기: 5점
- 비숍 잡기: 3점
- 폰 잡기: 1점

**실시간 전략 게임 예제:**
유닛 개수, 유닛 가치, 건강 상태, 자원량, 확보 영역 등을 종합적으로 고려한다.

### 결정 이론 알고리즘

1. **준비물**: Utility 함수, 실행 가능한 행동 목록, 시뮬레이션 방법
2. **실행**: 각 행동의 결과를 시뮬레이션하고 Utility 값을 계산
3. **선택**: 최대 Utility 값을 가지는 행동을 실행

### 불확실성 처리

게임에서는 완벽한 정보를 얻기 어렵다. 이를 해결하기 위해:

- **Cheating**: AI가 모든 정보에 접근하도록 허용
- **Simulator**: 행동 결과를 예측할 도구 제공
- **Monte Carlo 방법**: 여러 번 시뮬레이션하고 결과를 평균화

---

## 실제 게임 적용 사례: The Sims

The Sims는 2단계 Utility 시스템을 사용한다:

1. **레벨 1**: 동기 평가 (배고픔, 재미 등)
2. **레벨 2**: 행동 선택 (주스 마시기 등)

가장 강한 동기를 선택한 후, 그 동기를 가장 효과적으로 만족시키는 행동을 택한다.

---

## 결정 이론의 한계와 고려사항

### 한계점

- **즉각적 결과만 고려**: 장기적 전략을 세우지 못한다
- **상대방 계획 무시**: 플레이어의 의도를 예측하지 않는다
- **재미 요소 부족**: 너무 최적화된 플레이로 재미가 떨어질 수 있다

### 게임 디자인 고려사항

게임의 최종 목적은 재미다. Utility 함수가 지나치게 최적의 플레이를 추구하면, 플레이어에게 쉴 여유를 주지 않고 끊임없이 공격하는 등 재미없는 게임이 될 수 있다.

---

## 마무리

게임 AI의 의사결정은 단순한 스크립팅부터 복잡한 결정 이론까지 다양한 방법이 있다. 각각의 방법은 고유한 장단점을 가지고 있으며, 게임의 특성과 목적에 따라 적절한 방법을 선택해야 한다.

중요한 것은 AI가 아무리 똑똑하더라도 게임의 재미를 해치지 않아야 한다는 점이다. 완벽한 AI보다는 플레이어가 즐길 수 있는 AI를 만드는 것이 게임 개발의 핵심이다.
