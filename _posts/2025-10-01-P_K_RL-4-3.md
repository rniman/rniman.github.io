---
title: 파이썬과 케라스로 배우는 강화학습 | 강화학습 기초 9
date: 2025-10-01 11:57:35 +0900
categories: [Study, Study\ReinforceLearning]
tags: [AI, Reinforce Learning, Python, Book Note]
author: "rniman"                            # for single entry
# or
# authors: [<author1_id>, <author2_id>]   # for multiple entries
description: "파이썬과 케라스로 배우는 강화학습 Chapter 4 정리"
math: true
comments: false # 댓글 기능
---

## 책 정보 📖 

- 책 제목: 파이썬과 케라스로 배우는 강화학습
- 글쓴이: 이웅원, 양혁렬, 김건우, 이영무, 이의령
- 출판사: 위키북스
- 발행일: 2020년 04월 07일
- 챕터: Chapter 4. 강화학습 기초 3: 그리드월드와 큐러닝

### 책소개
강화학습의 기초부터 최근 알고리즘까지 친절하게 설명합니다!
‘알파고’로부터 받은 신선한 충격으로 많은 사람들이 강화학습에 관심을 가지기 시작했다. 하지만 처음 강화학습을 공부하는 분들을 위한 쉬운 자료나 강의를 찾아보기 어려웠다. 외국 강의를 통해 어렵게 이론을 공부하더라도 강화학습을 구현하는 데는 또 다른 장벽이 있었다. 이 책은 강화학습을 처음 공부하는 데 어려움을 겪는 독자를 위해 이론부터 코드 구현까지의 가이드를 제시한다.

특히 이번 개정판에서는 텐서플로 버전업에 맞춰서 코드를 업데이트하고 전반적인 이론 및 코드 설명을 개선했다. 그리고 실무에서 많이 활용될 수 있는 연속적 액터-크리틱 알고리즘을 추가했다.

* 출처 : [파이썬과 케라스로 배우는 강화학습 - 교보문고](https://product.kyobobook.co.kr/detail/S000001766424)

### 주요 내용
- 강화학습의 기초 - SARSA

정책 이터레이션과 가치 이터레이션이 발전하여 탄생한 SARSA 알고리즘에 대해 알아보자. SARSA부터가 진정한 의미의 강화학습이라 할 수 있다.

---

## GPI (Generalized Policy Iteration)

### GPI의 개념

정책 이터레이션의 정책 평가 과정을 참 가치함수로 수렴할 때까지 계산하지 않고 정책 평가와 정책 발전을 한 번씩 번갈아 가면서 실행하면 가치함수가 참 가치함수에 수렴한다.

이러한 정책 이터레이션을 **GPI(Generalized Policy Iteration)**라고 한다. 단 한 번만 정책을 평가해서 가치함수를 업데이트하고 바로 정책을 발전하는 과정을 반복한다.

### 강화학습 관점에서의 GPI

강화학습에서는 몬테카를로 예측이나 시간차 예측을 사용해 정책을 평가한다.

- GPI는 탐욕 정책 발전을 통해 주어진 가치함수에 대해 새로운 정책을 얻는다
- 시간차 방법은 타임스텝마다 가치함수를 현재 상태에 대해서만 업데이트한다
- 때문에 GPI처럼 모든 상태의 정책을 발전시킬 수 없다
- 시간차 방법에서는 별도의 정책 없이 가치함수에 대해 탐욕적으로 움직인 가치 이터레이션의 방법을 이용한다
- 즉, 현재 상태에서 에이전트는 가장 큰 가치를 지니는 행동을 선택하는 탐욕 정책을 사용한다
- **시간차 예측과 탐욕 정책이 합쳐진 것을 시간차 제어**라 한다

### GPI와 시간차 제어의 대응 관계

| GPI            | 시간차 제어 |
| -------------- | ----------- |
| 정책 평가      | 시간차 예측 |
| 탐욕 정책 발전 | 탐욕 정책   |

---

## 큐함수 기반 탐욕 정책

### GPI의 탐욕 정책 발전

$\pi^\prime (s) = \arg\max_{a \in A} E_\pi [R_{t+1} + \gamma v_{\pi}(S_{t+1}) \| S_t = s, A_t = a]$

GPI의 탐욕 정책 발전이다:

- 현재 상태를 발전시키기 위해서는 argmax 안에 들어있는 값의 최댓값을 알아야 한다
- GPI는 환경의 모델인 $P_{s s^\prime}^{a}$를 알아야 한다
- 따라서 시간차 제어의 탐욕 정책을 사용할 수 없다

**핵심 아이디어**: 다음 상태의 가치함수가 아닌 현재 상태의 큐함수를 보고 판단한다면 환경의 모델을 몰라도 된다.

### 큐함수를 사용한 탐욕 정책

$\pi (s) = \arg\max_{a \in A} Q(s,a)$

큐함수를 사용한 탐욕 정책이다:

- $Q$는 에이전트가 추정하는 값이기에 대문자로 표현한다
- 시간차 제어에서는 위의 수식으로 표현되는 탐욕 정책을 통해 행동을 선택한다
- **시간차 제어에서는 업데이트하는 대상이 가치함수가 아닌 큐함수가 돼야 한다**

---

## SARSA 알고리즘

### 큐함수의 업데이트

$$Q(S_t, A_t) \leftarrow Q(S_t, A_t) + \alpha(R_{t+1} + \gamma Q(S_{t+1}, A_{t+1}) - Q(S_t,A_t))$$

시간차 제어에서 큐함수의 업데이트 식이다.

### SARSA 샘플

$[S_t, A_t, R_{t+1}, S_{t+1}, A_{t+1}]$

시간차 제어에서 큐함수를 업데이트하려면 샘플이 필요하다:

- $[S_t, A_t, R_{t+1}, S_{t+1}, A_{t+1}]$을 샘플로 사용하여 큐함수를 업데이트한다
- 샘플인 상태 $S_t$에서 탐욕정책에 따라 $A_t$를 선택하고 행동으로 한 타임스텝 진행한다
- 환경은 보상 $R_{t+1}$과 다음 상태 $S_{t+1}$를 알려준다
- 한 번 더 탐욕 정책에 따라 행동 $A_{t+1}$을 선택해 샘플을 만든다

### SARSA의 의미

**시간차 제어를 다른 말로 SARSA라고 부른다.**

SARSA는 샘플의 구성 요소인 **S**tate, **A**ction, **R**eward, **S**tate, **A**ction의 첫 글자를 딴 것이다.

현재 가지고 있는 큐함수를 토대로 샘플을 탐욕 정책으로 모으고 그 샘플로 방문한 큐함수를 업데이트하는 과정을 반복한다.

---

## 탐험의 문제

### 탐욕 정책의 한계

이미 충분히 많은 경험을 한 에이전트는 탐욕 정책이 좋은 선택이지만 초기의 에이전트에게 탐욕 정책은 잘못된 학습으로 가게 할 가능성이 크다.

에이전트가 잘못된 정책을 학습하는 것을 막기 위해 충분히 다양한 경험을 하도록 해야 한다. 이것을 **탐험의 문제**라고 한다.

---

## ε-탐욕 정책 (Epsilon-Greedy Policy)

### ε-탐욕 정책의 개념

탐욕 정책을 대체할 새로운 정책으로 **ε만큼의 확률로 탐욕적이지 않은 행동을 선택하게** 하는 것이다:

- 현재 가지고 있는 큐함수는 수렴 전까지 편향돼 있는 정확하지 않은 값이다
- 에이전트가 때로는 큐함수를 토대로 탐욕적인 행동 대신 ε 확률로 엉뚱한 행동을 하도록 한다
- 에이전트가 지속적인 탐험이 가능하게 한다

### ε-탐욕 정책의 한계와 개선

**한계**: 최적 큐함수를 찾더라도 계속 탐험을 하게 된다는 한계가 있다.

**개선 방법**: ε을 학습의 진행에 따라 감소시킬 수도 있다.

### GPI와 SARSA의 완전한 대응 관계

| GPI            | SARSA       |
| -------------- | ----------- |
| 정책 평가      | 시간차 예측 |
| 탐욕 정책 발전 | ε-탐욕 정책 |

---

## SARSA의 두 단계

SARSA 알고리즘은 다음 두 단계를 반복한다:

### 1단계: 샘플 획득
ε-탐욕 정책을 통해 샘플 $[S_t, A_t, R_{t+1}, S_{t+1}, A_{t+1}]$을 획득한다.

### 2단계: 큐함수 업데이트
획득한 샘플로 큐함수 $Q(S_t, A_t)$를 업데이트한다.

$$Q(S_t, A_t) \leftarrow Q(S_t, A_t) + \alpha(R_{t+1} + \gamma Q(S_{t+1}, A_{t+1}) - Q(S_t,A_t))$$

---

## SARSA의 특징 정리

### 주요 특징

1. **온-폴리시(On-Policy)**: SARSA는 자신이 따르는 정책으로 샘플을 수집하고 그 정책을 개선한다
2. **실시간 학습**: 시간차 방법을 사용하므로 매 타임스텝마다 학습이 가능하다
3. **모델 프리(Model-Free)**: 환경의 모델을 몰라도 학습할 수 있다
4. **탐험과 활용의 균형**: ε-탐욕 정책을 통해 탐험과 활용의 균형을 맞춘다

### SARSA의 의의

SARSA는 다이내믹 프로그래밍에서 진정한 강화학습으로의 전환점이 되는 알고리즘이다:

- 환경 모델 없이 학습 가능
- 실시간 업데이트 가능
- 탐험 문제에 대한 해결책 제시
- 후에 등장할 큐러닝(Q-Learning)의 기반이 됨

이러한 특징들로 인해 SARSA는 실제 환경에서 적용 가능한 강화학습 알고리즘의 시작점이라 할 수 있다.
